[day12]

1. 상속 (inheritance)
	1) 클래스와 클래스 사이 (1:1) 의 부모 자식관계를 만듬
	2) 자바 다중상속 X (ex : extends Super1, Super2,.... 여러클래스 상속 받지 X)
	3) 상속은 부모의 변수, 메서드를 물려받는 것
		메모리를 갖는 클래스자체 또는 객체 사이의 상속이 아니다.
	4) 상속 시, 생성자와 초기화블럭은 제외
	5) 상속 키워드 : extends
	6) 상속을 받으면 부모의 멤버들을 복사해서 자식이 담게 된다. (눈에 안보이지만 가지고 있음)
		-> 자식은 부모의 것과 함께 자식만의 변수와 기능을 갖게 된다.
	7) 필요한 이유 : 코드 중복을 제거 -> 클래스를 간결하게 구현, 유지보수 편함, 소프트웨어 생산성 향상.
	

	부모 클래스 = super = parent = base
	자손 클래스 = sub = child = derived

	class Object{}					: 모두의 조상님
	class Parent{}	(extends Object 생략)		: 할아버지 x
	class Child extends Parent{}			: 아빠 : x,y
	class Child2 extends Parent{} 			: 삼촌 : x,a -----> 아빠와 관계 없음
	class GrendChild extends Child()			: 아들/딸 : x,y,z

 	8) Object 클래스 : 모든클래스의 조상
		: 자바에서 상속을 하나도 안받은 클래슨느 자동으로 Object 클래스를 상속받는다.
		그래서 모든 클래스는 Object 클래스의 멤버를 모두 사용 가능하다.
		: Object 클래스는 11개의 메서드만 가지고 있다.
		: 클래스안에 아무것도 없는 클래스를 만들어도 Object 클래스 용량만큼 메모리 차지함
		
		[Object 클래스 메서드]
		# clone()	: 객체 복사
		# equals()	: 객체의 주소가 같은 지 ==
		# finalize()	: 참조하고 있는 것이 없으면 가비지 컬렉션에 의해 이 메서드 호출
		# getClass()	: 현재 동작중인 클래스를 리턴
		# hashCode()	: 객체의 주소
		# notify()	: thread 제어하는 것 (notifyAll())
		# toString()	: new라고 만든 객체는 문자열 하나를 가지고 있고, 그것을 출력해주는 메서드
		# wait()	: thread에서 사용할것 (3개 있음. 오버로딩)

	9) package : 프로그램에서 폴더들 말함. 보통 패키지는 3수준까지 내려가는 폴더 이름을 작성한다.
			ex) java.awt.color.......

	10) java.lang : 가장 기본적인 package
			그 안에 존재하는 Object 클래스는 클래스 계층의 루트
	

2. 상속과 접근제어자
	1) 슈퍼클래스의 private멤버
		오직 현재 클래스의 멤버들에게만 접근 허용. 서브클래스 포함 다른 클래스에서 접근 X
	2) 슈퍼클래스의 default멤버
		패키지 내 모든 클래스가 접근 가능. 서브클래스라도 다른 패키지면 접근 X
	3) 슈퍼클래스의 public 멤버
		모든 클래스에서 접근 가능
	4) 슈퍼클래스의 protected 멤버
		같은 패키지에 속한 모든 클래스에서 접근 가능
		패키지 상관없이 서브클래스도 접근 가능

3. 상속과 생성자
	1) 서브와 수퍼클래스의 생성자 호출 및 실행
		서브 클래스가 생성될때, 서브 클래스의 생성자와 수퍼 클래스의 생성자 모두 실행? 서브만?
		--> 둘 다 실행. 생성자의 목적은 객체의 초기화이므로, 완성된 객체를 만들기 위해서는 둘 다 필요.
			생성자 실행 순서 : 수퍼 -> 서브
	2) 서브클래스에서 수퍼클래스 생성자 선택
		: 수퍼클래스에 생성자가 여러개 있는 경우, 개발자가 수퍼생성자를 명시적으로 지정하지 않는 경우,
		  컴파일러는 자동으로 수퍼클래스의 기본생성자를 호출하도록 컴파일함.
		#1. 수퍼클래스의 기본 생성자가 자동으로 선택되는 경우
			서브클래스 객체 생성시, 지정을 하지 않으면 자동으로 수퍼의 기본 생성자 호출
			특별한 수퍼 생성자 지정없이, 기본생성자가 없으면 에러!!!

		#2. super()를 이용하여 수퍼 클래스의 생성자 선택
			수퍼클래스의 생성자를 명시해주는 것이 원칙. 지금까지는 컴파일러가 자동으로 처리해줌.
			상속시 생성자는 물려받지 못하므로, super() 메서드를 이용하여 호출
			super(); 수퍼클래스 생성자를 호출하는 명령어, 괄호안에 인자 넣어 호출가능.
			주의 : this()와 같이 super()또한 생성자 내에 첫줄에 와야한다 (즉,두개같이 사용불가)

4. 오버라이딩 overriding
	1) 상속관계에서 성립
	2) 재작성, 덮어씌우기, 재정의한다~~ : 부모 클래스의 메서드가 맘에 들지 않아서 내용을 변경해서 사용하는 것.
	3) 메서드 선언부는 똑같이, 블럭(영역)안 내용만 바꾸는것
	4) 오버로드와 완전히 다름. 오버라이딩은 안에 내용을 변경해서 덮어씌우는 형태, 오버로딩은 새로운 메서드 만드는 것
		equals(), toString() 은 그대로 사용 잘 안하고 대부분 오버라이딩 해서 사용함.
	5) 동적바인딩(Dynamic binding) : 서브에서 오버라이딩 메서드가 있으면, 슈퍼클래스의 메서드를 무시하고
		서브 클래스에서 오버라이딩된 메서드가 무조건 실행되도록 한다.
		메서드 오버라이딩은 동적바인딩을 유발시킨다.
		실행할때 메서드를 컴파일시(compile time)에 결정하지 않고,
		실행시 (run time)에 결정하는 것을 말함.
	6) @Override : 어노테이션이라 부르며, 메서드 바로 위에 붙혀서 컴파일러에게 오버라이딩이 정확한지 확인하도록 지시하는 것.
			코드의 가독성을 높이고, 개발자가 실수로 잘못 작성하거나 오타를 방지하기 위한 기능.
	7) 수퍼클래스 메서드의 접근지정자 보다 접근의 범위를 좁혀 오버라이딩 불가.
		public > protected > default > private
		슈퍼가 protected면 서브에서 오버라이딩은  protected나 public 형태만 가능
		슈퍼가 public이면 서브에서 오버라이딩은 public만 가능
		
	8) super : 자바 컴파일러에 의해 지원되는 수퍼클래스에 대한 레퍼런스. 수퍼클래스 지정.
		서브클래스에 메서드 오버라이딩시, 동적 바인딩으로 오버라이딩된 메서드가 자동호출되는데,
		이 키워드를 이용하면 정적바인딩을 통해 슈퍼클래스의 멤버(변수,메서드)에 접근 가능

## this, super, this(), super()
	this : 현재 객체의 모든 멤버 접근 가능 키워드
	super : 현재 객체의 슈퍼클래스(부모클래스) 멤버 접근 가능 키워드
	this() : 생성자에서 다른 생성자 호출할때 사용
	super() : 서브 클래스의 생성자에서 슈퍼클래스(부모클래스)의 생성자를 호출할때 사용

5. 다형성 polymorphism * 중요!!

	여러가지 형태를 가질 수 있는 능력
	상속관계에서 성립가능한 문법
	참조형의 업/다운캐스팅(promotion/demotion)