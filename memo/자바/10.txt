[day10]

1. 객체 배열
	1) 배열은 기본타입 뿐만 아니라, 객체를 원소로 하는 객체 배열도 만들 수 있다.
	2) 객체에 대한 레퍼런스(주소)를 원소로 갖는 배열이다.
	3) 배열 선언 및 생성
		#1.배열에 대한 레버런스 변수 선언
			int [] arr;
			클래스명 [] 변수명;
	
		#2. 레퍼런스 배열 생성
		
			arr = new int [5];	//int 형 배열
			배열변수명 = new 클래스명[개수];// 객체배열

		#3. 배열의 원소 객체 접근
			arr[0]
			배열변수명[인덱스].멤버변수
			배열변수명[인덱스].메서드()

2. 가비지
	1) 더이상 사용되지 않는 객체나 배열 메모리를 칭함.
	2) 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 판단.

		a=new Book("a","b");
		b=new Book("c","d");

		b=a;


		---> b 레퍼런스 변수가 가르키던 객체(new Book("c","d"))는 이제 가비지가 된다.

3. 가비지 컬렉션(Garbage Collection)
	1) 가비지가 많으면 사용할 수 있는 가용 메모리가 줄어든다--> 메모리 부족하면 프로그램 실행 X
		자바 플렛폼은 가용메모리가 일정 크기이하로 줄어들면 자동으로 가비지 회수한다.
		이를 가비지 컬렉션이라 함.	
	2) 가비지 컬력션은 가비지 컬렉션 스레드에 의해 처리된다.
	3) 자바 플렛폼 내부의 판단에 의해 실행되므로, 언제 가비지 컬레션이 수행되는지 알기 어렵다.
	4) 단점 : 가비지 컬렉터가 실행되면 응용 프로그램은 실행을 멈추고 기다린다.
		--> 실시간 처리 응용프로그램으로 부적합(예 > 온라인게임개발)
	5) 강제 용청은 System 또는 RunTime 객체의 gc()메소드를 호출하면 요청할 수 있으나 즉시 작동하지 않는다. 

4. 접근지정자(modifier)

	1) 객체 지향 언어는 접근지정자를 두고 있다.
		객체를 캡슐화하기 때문에, 객체에 다른 객체가 접근하는 것을 허용할지 말지를
		지정할 필요가 있기 때문
	
	2) 패키지 (package)
		자바는 서로 관련있는 클래스 파일들을 패키지에 저장하여 관리.
		패키지 : 디렉토리 or 폴더
		
	3) 자바의 4가지 접근 지정자
		
		# 클래스 접근 지정자 : 다른 클래스에서 이 클래스를 활용할 수 있는지 허용 여부 지정.

		1. public 클래스
			: 패키지에 상관없이 다른 어떤 클래스에서도 사용이 허용됨

			public class 클래스명{
				// 변수, 메서드, 생성자....
			}
		2. default 클래스 (접근 지정자를 생략)
			: 같은 패키지내의 클래스들에게만 사용이 허용됨.
			class 클래스명{
				// 변수, 메서드, 생성자.....
		}

		주의 : 한 파일에는 public 클래스가 한개만 존재한다. -> (수업할때는 보통) main() 메서드 가지고 있다.

		# 멤버 접근 지정자   : 

		----------------------------------------------------------------------------------------------
		멤버에 접근하는 클래스 |		멤버접근 지정자			|
				       | private  |  default  |  protected  |  public	|
		----------------------------------------------------------------------------------------------
		 같은 패키지의 클래스  |    X	  |     O     |	     O      |     O
		----------------------------------------------------------------------------------------------
		 다른 패키지의 클래스  |    X     |     X     |      X      |     O
		----------------------------------------------------------------------------------------------
		 접근 가능 영역	       | 클래스내 | 동일패키지| 동일패키지와| 모든클래스
								자식클래스

		----------------------------------------------------------------------------------------------
		private< default < protected < public	
	

		1. pubilc 멤버 *
			: 모든 클래스에서 접근 가능
			public 타입 변수명;
			public 리턴타입 메서드명(){....}

		2. private 멤버 *
			: 비공개, 클래스내의 멤버들에게만 접근 허용
			
			private 타입 변수명;
			private 리턴타입 메서드명(){...}

		3. protected 멤버
			: 보호된 공개, 같은 패키지의 모든 클래스와 다른 패키지의 자식클래스   --> 상속유도

			protected 타입 변수명;
			protected 리턴타입 메서드명(){...}
		4. default 멤버 (접근지정자 생략)
			: 동일한 패키지 내 클래스들에게 접근 허용

			타입 변수명;
			리턴타입 메서드명(){....}
			
	4) 캡슐화(encapsulation) : 자바가 추구하는 코딩 형태

		변수 : private (인스턴스 변수,클래스 변수)
		메서드 : public
		
		데이터를 보관하는 변수에 접근하기 위해서는 메서드를 이용하여 우회접근 하도록한다.
		데이터의 공개를 막고, 적합한 가공과 검증을 통하여 데이터에 접근하도록 유도하기 위한 방법.
		--> getter / setter : get변수명() : 데이터 꺼내기, set변수명() : 데이터 대입.

5. final(3군데 사용..)

	1) final 클래스
		클래스 앞에 붙으면, 상속 할 수 없음을 지정함
		final class 클래스명{...}
		final class SuperClass{...}
		class SubClass extends SuperClass{...} ---> 불가능
	2) final 메서드
		메서드 앞에 붙으면, 오버라이딩 할 수 없음을 선언함.
			
	3) final 변수
		변수 앞에 붙으면, 상수가 된다.
		상수는 한번 초기화되면 값을 변경 할 수 없다.
		int abc =10;//변수
		final int ABC = 10;//상수
		ABC =20; ---> X 불가능
		상수는 관례적으로 상수명을 전부 대문자로 짓는다.

		final 키워드를 public static과 함께 선언하면 프로그램 전체에서 사용할 수 있는 상수가 된다.
		ex) public static final double PI=3.14......;